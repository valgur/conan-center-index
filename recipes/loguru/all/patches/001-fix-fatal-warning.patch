Fixes

loguru.cpp: In function ‘void loguru::escape(std::string&, const std::string&)’:
loguru.cpp:571:36: error: comparison is always true due to limited range of data type [-Werror=type-limits]
  571 |                         else if (0 <= c && c < 0x20) { // ASCI control character:
      |                                  ~~^~~~
loguru.cpp: In function ‘loguru::Text loguru::ec_to_text(char)’:
loguru.cpp:1845:28: error: comparison is always true due to limited range of data type [-Werror=type-limits]
 1845 |                 else if (0 <= c && c < 0x20) {
      |                          ~~^~~~
cc1plus: all warnings being treated as errors

--- a/loguru.cpp
+++ b/loguru.cpp
@@ -556,7 +556,7 @@
 
 	static void escape(std::string& out, const std::string& str)
 	{
-		for (char c : str) {
+		for (unsigned char c : str) {
 			/**/ if (c == '\a') { out += "\\a";  }
 			else if (c == '\b') { out += "\\b";  }
 			else if (c == '\f') { out += "\\f";  }
@@ -568,7 +568,7 @@
 			else if (c == '\'') { out += "\\\'"; }
 			else if (c == '\"') { out += "\\\""; }
 			else if (c == ' ')  { out += "\\ ";  }
-			else if (0 <= c && c < 0x20) { // ASCI control character:
+			else if (c < 0x20) { // ASCII control character:
 			// else if (c < 0x20 || c != (c & 127)) { // ASCII control character or UTF-8:
 				out += "\\x";
 				write_hex_byte(out, static_cast<uint8_t>(c));
@@ -1814,7 +1814,7 @@
 		return Text{STRDUP(str.c_str())};
 	}
 
-	Text ec_to_text(char c)
+	Text ec_to_text(unsigned char c)
 	{
 		// Add quotes around the character to make it obvious where it begin and ends.
 		std::string str = "'";
@@ -1842,7 +1842,7 @@
 		else if (c == '\n') { str += "\\n";  }
 		else if (c == '\r') { str += "\\r";  }
 		else if (c == '\t') { str += "\\t";  }
-		else if (0 <= c && c < 0x20) {
+		else if (c < 0x20) {
 			str += "\\u";
 			write_hex_16(static_cast<uint16_t>(c));
 		} else { str += c; }
